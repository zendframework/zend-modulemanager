{
    "docs": [
        {
            "location": "/", 
            "text": "../../README.md", 
            "title": "Home"
        }, 
        {
            "location": "/intro/", 
            "text": "Introduction to the Module System\n\n\nZend Framework 2.0 introduced a new and powerful approach to modules. This new\nmodule system is designed with flexibility, simplicity, and re-usability in\nmind. A module may contain just about anything: PHP code, including MVC\nfunctionality; library code; view scripts; and/or public assets such as images,\nCSS, and JavaScript. The possibilities are endless.\n\n\n\n\nEvent-based system\n\n\nThe module system in ZF2 has been designed to be a generic and powerful foundation from which\ndevelopers and other projects can build their own module or plugin systems.\nFor a better understanding of the event-driven concepts behind the ZF2 module system, it may be\nhelpful to read the \nEventManager documentation\n.\n\n\n\n\nThe module system is made up of the following:\n\n\n\n\nThe Module Autoloader\n -\n  \nZend\\Loader\\ModuleAutoloader\n is a specialized autoloader that is responsible\n  for the locating and loading of modules' \nModule\n classes from a variety of\n  sources.\n\n\nThe Module Manager\n - \nZend\\ModuleManager\\ModuleManager\n\n  takes an array of module names and fires a sequence of events for each one,\n  allowing the behavior of the module system to be defined entirely by the\n  listeners which are attached to the module manager.\n\n\nModuleManager Listeners\n - Event listeners can be attached to the module\n  manager's various events. These listeners can do everything from resolving and\n  loading modules to performing complex initialization tasks and introspection\n  into each returned module object.\n\n\n\n\n\n\nModules are PHP namespaces\n\n\nThe name of a module in a Zend Framework application is a\n\nPHP namespace\n, and must follow all of the same\nrules for naming.\n\n\n\n\nThe recommended structure for an MVC-oriented ZF2 module is as follows:\n\n\nmodule_root/\n    Module.php\n    autoload_classmap.php\n    autoload_function.php\n    autoload_register.php\n    config/\n        module.config.php\n    public/\n        images/\n        css/\n        js/\n    src/\n        \nmodule_namespace\n/\n            \ncode files\n\n    test/\n        phpunit.xml\n        bootstrap.php\n        \nmodule_namespace\n/\n            \ntest code files\n\n    view/\n        \ndir-named-after-module-namespace\n/\n            \ndir-named-after-a-controller\n/\n                \n.phtml files\n\n\n\nThe autoload_*.php Files\n\n\nThe three \nautoload_*.php\n files are not required, but recommended. They provide the following:\n\n\n\n\nautoload_classmap.php\n should return an array classmap of class name/filename\n  pairs (with the filenames resolved via the \n__DIR__\n magic constant).\n\n\nautoload_function.php\n should return a PHP callback that can be passed to\n  \nspl_autoload_register()\n. Typically, this callback should utilize the map\n  returned by \nautoload_classmap.php\n.\n\n\nautoload_register.php\n should register a PHP callback (typically that\n  returned by \nautoload_function.php\n with \nspl_autoload_register()\n.\n\n\n\n\nThe purpose of these three files is to provide reasonable default mechanisms for\nautoloading the classes contained in the module, thus providing a trivial way to\nconsume the module without requiring zend-modulemanager` (e.g., for use outside\na ZF2 application).", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#introduction-to-the-module-system", 
            "text": "Zend Framework 2.0 introduced a new and powerful approach to modules. This new\nmodule system is designed with flexibility, simplicity, and re-usability in\nmind. A module may contain just about anything: PHP code, including MVC\nfunctionality; library code; view scripts; and/or public assets such as images,\nCSS, and JavaScript. The possibilities are endless.", 
            "title": "Introduction to the Module System"
        }, 
        {
            "location": "/intro/#event-based-system", 
            "text": "The module system in ZF2 has been designed to be a generic and powerful foundation from which\ndevelopers and other projects can build their own module or plugin systems.\nFor a better understanding of the event-driven concepts behind the ZF2 module system, it may be\nhelpful to read the  EventManager documentation .   The module system is made up of the following:   The Module Autoloader  -\n   Zend\\Loader\\ModuleAutoloader  is a specialized autoloader that is responsible\n  for the locating and loading of modules'  Module  classes from a variety of\n  sources.  The Module Manager  -  Zend\\ModuleManager\\ModuleManager \n  takes an array of module names and fires a sequence of events for each one,\n  allowing the behavior of the module system to be defined entirely by the\n  listeners which are attached to the module manager.  ModuleManager Listeners  - Event listeners can be attached to the module\n  manager's various events. These listeners can do everything from resolving and\n  loading modules to performing complex initialization tasks and introspection\n  into each returned module object.", 
            "title": "Event-based system"
        }, 
        {
            "location": "/intro/#modules-are-php-namespaces", 
            "text": "The name of a module in a Zend Framework application is a PHP namespace , and must follow all of the same\nrules for naming.   The recommended structure for an MVC-oriented ZF2 module is as follows:  module_root/\n    Module.php\n    autoload_classmap.php\n    autoload_function.php\n    autoload_register.php\n    config/\n        module.config.php\n    public/\n        images/\n        css/\n        js/\n    src/\n         module_namespace /\n             code files \n    test/\n        phpunit.xml\n        bootstrap.php\n         module_namespace /\n             test code files \n    view/\n         dir-named-after-module-namespace /\n             dir-named-after-a-controller /\n                 .phtml files", 
            "title": "Modules are PHP namespaces"
        }, 
        {
            "location": "/intro/#the-autoload9542php-files", 
            "text": "The three  autoload_*.php  files are not required, but recommended. They provide the following:   autoload_classmap.php  should return an array classmap of class name/filename\n  pairs (with the filenames resolved via the  __DIR__  magic constant).  autoload_function.php  should return a PHP callback that can be passed to\n   spl_autoload_register() . Typically, this callback should utilize the map\n  returned by  autoload_classmap.php .  autoload_register.php  should register a PHP callback (typically that\n  returned by  autoload_function.php  with  spl_autoload_register() .   The purpose of these three files is to provide reasonable default mechanisms for\nautoloading the classes contained in the module, thus providing a trivial way to\nconsume the module without requiring zend-modulemanager` (e.g., for use outside\na ZF2 application).", 
            "title": "The autoload_*.php Files"
        }, 
        {
            "location": "/module-manager/", 
            "text": "The Module Manager\n\n\nThe module manager, \nZend\\ModuleManager\\ModuleManager\n, is responsible for\niterating over an array of module names and triggering a sequence of events for\neach.  Instantiation of module classes, initialization tasks, and configuration\nare all performed by attached event listeners.\n\n\nModule Manager Events\n\n\nThe Module Manager events are defined in \nZend\\ModuleManager\\ModuleEvent\n.\n\n\nloadModules (\nModuleEvent::EVENT_LOAD_MODULES\n)\n\n\nThis event is primarily used internally to help encapsulate the work of loading\nmodules in event listeners, and allows the \nloadModules.post\n event to be more\nuser-friendly. Internal listeners will attach to this event with a negative\npriority instead of \nloadModules.post\n so that users can safely assume things like\nconfig merging have been done once \nloadModules.post\n is triggered, without having\nto worry about priorities.\n\n\nloadModule.resolve (\nModuleEvent::EVENT_LOAD_MODULE_RESOLVE\n)\n\n\nTriggered for each module that is to be loaded. The listener(s) to this event\nare responsible for taking a module name and resolving it to an instance of some\nclass. The default module resolver looks for the class \n{modulename}\\Module\n,\ninstantiating and returning it if it exists.\n\n\nThe name of the module may be retrieved by listeners using the \ngetModuleName()\n\nmethod of the \nEvent\n object; a listener should then take that name and resolve\nit to an object instance representing the given module. Multiple listeners can\nbe attached to this event, and the module manager will trigger them in order of\ntheir priority until one returns an object. This allows you to attach additional\nlisteners which have alternative methods of resolving modules from a given\nmodule name.\n\n\nloadModule (\nModuleEvent::EVENT_LOAD_MODULE\n)\n\n\nOnce a module resolver listener has resolved the module name to an object, the\nmodule manager then triggers this event, passing the newly created object to all\nlisteners.\n\n\nmergeConfig (\nModuleEvent::EVENT_MERGE_CONFIG\n)\n\n\nAfter all modules have been loaded, the \nmergeConfig\n event is triggered. By default,\n\nZend\\ModuleManager\\Listener\\ConfigLister\n listens on this event at priority 1000, and merges all\nconfiguration. You may attach additional listeners to this event in order to manipulate the merged\nconfiguration. See \nthe tutorial on manipulating merged configuration\n\nfor more information.\n\n\nloadModules.post (\nModuleEvent::EVENT_LOAD_MODULES_POST\n)\n\n\nThis event is triggered by the module manager to allow any listeners to perform\nwork after every module has finished loading. For example, the default\nconfiguration listener, \nZend\\ModuleManager\\Listener\\ConfigListener\n (covered\nlater), attaches to this event to merge additional user-supplied configuration\nwhich is meant to override the default supplied configurations of installed\nmodules.\n\n\nModule Manager Listeners\n\n\nBy default, Zend Framework provides several useful module manager listeners. All\nshipped listeners are in the \nZend\\ModuleManager\\Listener\n namespace.\n\n\nDefaultListenerAggregate\n\n\nTo address the most common use case of the module manager, ZF2 provides\nthis default aggregate listener. In most cases, this will be the only listener\nyou will need to attach to use the module manager, as it will take care of\nproperly attaching the requisite listeners (those listed below) for the module\nsystem to function properly.\n\n\nAutoloaderListener\n\n\nThis listener checks each module to see if it has implemented\n\nZend\\ModuleManager\\Feature\\AutoloaderProviderInterface\n or defined the\n\ngetAutoloaderConfig()\n method. If so, it calls the \ngetAutoloaderConfig()\n\nmethod on the module class and passes the returned array to\n\nZend\\Loader\\AutoloaderFactory\n.\n\n\nModuleDependencyCheckerListener\n\n\nThis listener checks each module to verify if all the modules it depends on were\nloaded. When a module class implements\n\nZend\\ModuleManager\\Feature\\DependencyIndicatorInterface\n or has defined the\n\ngetModuleDependencies()\n method, the listener will call\n\ngetModuleDependencies()\n. Each of the values returned by the method is checked\nagainst the loaded modules list: if one of the values is not in that list, a\n\nZend\\ModuleManager\\Exception\\MissingDependencyModuleException\n is thrown.\n\n\nConfigListener\n\n\nIf a module class has a \ngetConfig()\n method, or implements\n\nZend\\ModuleManager\\Feature\\ConfigProviderInterface\n, this listener will call it\nand merge the returned array (or \nTraversable\n object) into the main application\nconfiguration.\n\n\nInitTrigger\n\n\nIf a module class either implements \nZend\\ModuleManager\\Feature\\InitProviderInterface\n,\nor defines an \ninit()\n method, this listener will call \ninit()\n and pass the\ncurrent instance of \nZend\\ModuleManager\\ModuleManager\n as the sole parameter.\n\n\nLike the \nOnBootstrapListener\n, the \ninit()\n method is called for \nevery\n\nmodule implementing this feature, on \nevery\n page request and should \nonly\n\nbe used for performing \nlightweight\n tasks such as registering event\nlisteners.\n\n\nLocatorRegistrationListener\n\n\nIf a module class implements \nZend\\ModuleManager\\Feature\\LocatorRegisteredInterface\n,\nthis listener will inject the module class instance into the \nServiceManager\n\nusing the module class name as the service name. This allows you to later\nretrieve the module class from the \nServiceManager\n.\n\n\nModuleResolverListener\n\n\nThis is the default module resolver. It attaches to the \nloadModule.resolve\n\nevent and returns an instance of \n{moduleName}\\Module\n.\n\n\nOnBootstrapListener\n\n\nIf a module class implements\n\nZend\\ModuleManager\\Feature\\BootstrapListenerInterface\n, or defines an\n\nonBootstrap()\n method, this listener will register the \nonBootstrap()\n method\nwith the \nZend\\Mvc\\Application\n \nbootstrap\n event. This method will then be\ntriggered during the \nbootstrap\n event (and passed an \nMvcEvent\n instance).\n\n\nLike the \nInitTrigger\n, the \nonBootstrap()\n method is called for \nevery\n\nmodule implementing this feature, on \nevery\n page request, and should \nonly\n\nbe used for performing \nlightweight\n tasks such as registering event\nlisteners.\n\n\nServiceListener\n\n\nIf a module class implements \nZend\\ModuleManager\\Feature\\ServiceProviderInterface\n,\nor defines an \ngetServiceConfig()\n method, this listener will call that method\nand aggregate the return values for use in configuring the \nServiceManager\n.\n\n\nThe \ngetServiceConfig()\n method may return either an array of configuration\ncompatible with \nZend\\ServiceManager\\Config\n, an instance of that class, or the\nstring name of a class that extends it. Values are merged and aggregated on\ncompletion, and then merged with any configuration from the \nConfigListener\n\nfalling under the \nservice_manager\n key. For more information, see the\n\nServiceManager\n documentation.\n\n\nUnlike the other listeners, this listener is not managed by the \nDefaultListenerAggregate\n;\ninstead, it is created and instantiated within the\n\nZend\\Mvc\\Service\\ModuleManagerFactory\n, where it is injected with the current\n\nServiceManager\n instance before being registered with the \nModuleManager\n\nevents.\n\n\nAdditionally, this listener manages a variety of plugin managers, including\n\nview helpers\n,\n\ncontrollers\n, and\n\ncontroller plugins\n. In each case,\nyou may either specify configuration to define plugins, or provide configuration via a \nModule\n\nclass. Configuration follows the same format as for the \nServiceManager\n. The following table\noutlines the plugin managers that may be configured this way (including the \nServiceManager\n), the\nconfiguration key to use, the \nModuleManager\n feature interface to optionally implement (all\ninterfaces specified live in the \nZend\\ModuleManager\\Feature\n namespace) , and the module method to\noptionally define to provide configuration.\n\n\n\n\n\n\n\n\nPlugin Manager\n\n\nConfig Key\n\n\nInterface\n\n\nModule Method\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Controller\\ControllerManager\n\n\ncontrollers\n\n\nControllerProviderInterface\n\n\ngetControllerConfig\n\n\n\n\n\n\nZend\\Mvc\\Controller\\PluginManager\n\n\ncontroller_plugins\n\n\nControllerPluginProviderInterface\n\n\ngetControllerPluginConfig\n\n\n\n\n\n\nZend\\Filter\\FilterPluginManager\n\n\nfilters\n\n\nFilterProviderInterface\n\n\ngetFilterConfig\n\n\n\n\n\n\nZend\\Form\\FormElementManager\n\n\nform_elements\n\n\nFormElementProviderInterface\n\n\ngetFormElementConfig\n\n\n\n\n\n\nZend\\Stdlib\\Hydrator\\HydratorPluginManager\n\n\nhydrators\n\n\nHydratorProviderInterface\n\n\ngetHydratorConfig\n\n\n\n\n\n\nZend\\InputFilter\\InputFilterPluginManager\n\n\ninput_filters\n\n\nInputFilterProviderInterface\n\n\ngetInputFilterConfig\n\n\n\n\n\n\nZend\\Mvc\\Router\\RoutePluginManager\n\n\nroute_manager\n\n\nRouteProviderInterface\n\n\ngetRouteConfig\n\n\n\n\n\n\nZend\\Serializer\\AdapterPluginManager\n\n\nserializers\n\n\nSerializerProviderInterface\n\n\ngetSerializerConfig\n\n\n\n\n\n\nZend\\ServiceManager\\ServiceManager\n\n\nservice_manager\n\n\nServiceProviderInterface\n\n\ngetServiceConfig\n\n\n\n\n\n\nZend\\Validator\\ValidatorPluginManager\n\n\nvalidators\n\n\nValidatorProviderInterface\n\n\ngetValidatorConfig\n\n\n\n\n\n\nZend\\View\\HelperPluginManager\n\n\nview_helpers\n\n\nViewHelperProviderInterface\n\n\ngetViewHelperConfig\n\n\n\n\n\n\nZend\\Log\\ProcessorPluginManager\n\n\nlog_processors\n\n\nLogProcessorProviderInterface\n\n\ngetLogProcessorConfig\n\n\n\n\n\n\nZend\\Log\\WriterPluginManager\n\n\nlog_writers\n\n\nLogWriterProviderInterface\n\n\ngetLogWriterConfig\n\n\n\n\n\n\n\n\nConfiguration follows the examples in the ServiceManager\n\nconfiguration section\n.\nAs a brief recap, the following configuration keys and values are allowed:\n\n\n\n\n\n\n\n\nConfig Key\n\n\nAllowed values\n\n\n\n\n\n\n\n\n\n\nservices\n\n\nservice name/instance pairs (these should likely be defined only in \nModule\n classes\n\n\n\n\n\n\ninvokables\n\n\nservice name/class name pairs of classes that may be invoked without constructor arguments (deprecated with zend-servicemanager v3; use the \nInvokableFactory\n instead)\n\n\n\n\n\n\nfactories\n\n\nservice names pointing to factories. Factories may be any PHP callable, or a string class name of a class implementing \nZend\\ServiceManager\\FactoryInterface\n, or of a class implementing the \n__invoke\n method (if a callable is used, it should be defined only in \nModule\n classes)\n\n\n\n\n\n\nabstract_factories\n\n\narray of either concrete instances of \nZend\\ServiceManager\\AbstractFactoryInterface\n, or string class names of classes implementing that interface (if an instance is used, it should be defined only in \nModule\n classes)\n\n\n\n\n\n\ninitializers\n\n\narray of PHP callables or string class names of classes implementing \nZend\\ServiceManager\\InitializerInterface\n (if a callable is used, it should be defined only in \nModule\n classes)\n\n\n\n\n\n\n\n\nWhen working with plugin managers, you will be passed the plugin manager instance to factories,\nabstract factories, and initializers. If you need access to the application services, you can use\nthe \ngetServiceLocator()\n method, as in the following example:\n\n\npublic function getViewHelperConfig()\n{\n    return ['factories' =\n [\n        'foo' =\n function ($helpers) {\n            $container   = $helpers-\ngetServiceLocator();\n            $someService = $container-\nget('SomeService');\n            $helper      = new Helper\\Foo($someService);\n\n            return $helper;\n        },\n    ]];\n}\n\n\n\nThis is a powerful technique, as it allows your various plugins to remain\nagnostic with regards to where and how dependencies are injected, and thus\nallows you to use Inversion of Control principals even with plugins.\n\n\n\n\nFactories with zend-servicemanager v3\n\n\nStarting in the v3 releases of zend-servicemanager, factories invoked by\nplugin managers now receive the \nparent\n container, and not the plugin manager\nitself. You can write your factories under v2, and prepare them for v3, by\ntesting the incoming argument to see if it is a plugin manager:\n\n\nuse Zend\\SserviceManager\\AbstractPluginManager;\n\nfunction ($container) {\n    $container = $container instanceof AbstractPluginManager\n        ? $container-\ngetServiceLocator()\n        : $container;\n\n    // create instance with dependencies pulled from app container...\n}", 
            "title": "The Module Manager"
        }, 
        {
            "location": "/module-manager/#the-module-manager", 
            "text": "The module manager,  Zend\\ModuleManager\\ModuleManager , is responsible for\niterating over an array of module names and triggering a sequence of events for\neach.  Instantiation of module classes, initialization tasks, and configuration\nare all performed by attached event listeners.", 
            "title": "The Module Manager"
        }, 
        {
            "location": "/module-manager/#module-manager-events", 
            "text": "The Module Manager events are defined in  Zend\\ModuleManager\\ModuleEvent .", 
            "title": "Module Manager Events"
        }, 
        {
            "location": "/module-manager/#loadmodules-moduleeventevent_load_modules", 
            "text": "This event is primarily used internally to help encapsulate the work of loading\nmodules in event listeners, and allows the  loadModules.post  event to be more\nuser-friendly. Internal listeners will attach to this event with a negative\npriority instead of  loadModules.post  so that users can safely assume things like\nconfig merging have been done once  loadModules.post  is triggered, without having\nto worry about priorities.", 
            "title": "loadModules (ModuleEvent::EVENT_LOAD_MODULES)"
        }, 
        {
            "location": "/module-manager/#loadmoduleresolve-moduleeventevent_load_module_resolve", 
            "text": "Triggered for each module that is to be loaded. The listener(s) to this event\nare responsible for taking a module name and resolving it to an instance of some\nclass. The default module resolver looks for the class  {modulename}\\Module ,\ninstantiating and returning it if it exists.  The name of the module may be retrieved by listeners using the  getModuleName() \nmethod of the  Event  object; a listener should then take that name and resolve\nit to an object instance representing the given module. Multiple listeners can\nbe attached to this event, and the module manager will trigger them in order of\ntheir priority until one returns an object. This allows you to attach additional\nlisteners which have alternative methods of resolving modules from a given\nmodule name.", 
            "title": "loadModule.resolve (ModuleEvent::EVENT_LOAD_MODULE_RESOLVE)"
        }, 
        {
            "location": "/module-manager/#loadmodule-moduleeventevent_load_module", 
            "text": "Once a module resolver listener has resolved the module name to an object, the\nmodule manager then triggers this event, passing the newly created object to all\nlisteners.", 
            "title": "loadModule (ModuleEvent::EVENT_LOAD_MODULE)"
        }, 
        {
            "location": "/module-manager/#mergeconfig-moduleeventevent_merge_config", 
            "text": "After all modules have been loaded, the  mergeConfig  event is triggered. By default, Zend\\ModuleManager\\Listener\\ConfigLister  listens on this event at priority 1000, and merges all\nconfiguration. You may attach additional listeners to this event in order to manipulate the merged\nconfiguration. See  the tutorial on manipulating merged configuration \nfor more information.", 
            "title": "mergeConfig (ModuleEvent::EVENT_MERGE_CONFIG)"
        }, 
        {
            "location": "/module-manager/#loadmodulespost-moduleeventevent_load_modules_post", 
            "text": "This event is triggered by the module manager to allow any listeners to perform\nwork after every module has finished loading. For example, the default\nconfiguration listener,  Zend\\ModuleManager\\Listener\\ConfigListener  (covered\nlater), attaches to this event to merge additional user-supplied configuration\nwhich is meant to override the default supplied configurations of installed\nmodules.", 
            "title": "loadModules.post (ModuleEvent::EVENT_LOAD_MODULES_POST)"
        }, 
        {
            "location": "/module-manager/#module-manager-listeners", 
            "text": "By default, Zend Framework provides several useful module manager listeners. All\nshipped listeners are in the  Zend\\ModuleManager\\Listener  namespace.", 
            "title": "Module Manager Listeners"
        }, 
        {
            "location": "/module-manager/#defaultlisteneraggregate", 
            "text": "To address the most common use case of the module manager, ZF2 provides\nthis default aggregate listener. In most cases, this will be the only listener\nyou will need to attach to use the module manager, as it will take care of\nproperly attaching the requisite listeners (those listed below) for the module\nsystem to function properly.", 
            "title": "DefaultListenerAggregate"
        }, 
        {
            "location": "/module-manager/#autoloaderlistener", 
            "text": "This listener checks each module to see if it has implemented Zend\\ModuleManager\\Feature\\AutoloaderProviderInterface  or defined the getAutoloaderConfig()  method. If so, it calls the  getAutoloaderConfig() \nmethod on the module class and passes the returned array to Zend\\Loader\\AutoloaderFactory .", 
            "title": "AutoloaderListener"
        }, 
        {
            "location": "/module-manager/#moduledependencycheckerlistener", 
            "text": "This listener checks each module to verify if all the modules it depends on were\nloaded. When a module class implements Zend\\ModuleManager\\Feature\\DependencyIndicatorInterface  or has defined the getModuleDependencies()  method, the listener will call getModuleDependencies() . Each of the values returned by the method is checked\nagainst the loaded modules list: if one of the values is not in that list, a Zend\\ModuleManager\\Exception\\MissingDependencyModuleException  is thrown.", 
            "title": "ModuleDependencyCheckerListener"
        }, 
        {
            "location": "/module-manager/#configlistener", 
            "text": "If a module class has a  getConfig()  method, or implements Zend\\ModuleManager\\Feature\\ConfigProviderInterface , this listener will call it\nand merge the returned array (or  Traversable  object) into the main application\nconfiguration.", 
            "title": "ConfigListener"
        }, 
        {
            "location": "/module-manager/#inittrigger", 
            "text": "If a module class either implements  Zend\\ModuleManager\\Feature\\InitProviderInterface ,\nor defines an  init()  method, this listener will call  init()  and pass the\ncurrent instance of  Zend\\ModuleManager\\ModuleManager  as the sole parameter.  Like the  OnBootstrapListener , the  init()  method is called for  every \nmodule implementing this feature, on  every  page request and should  only \nbe used for performing  lightweight  tasks such as registering event\nlisteners.", 
            "title": "InitTrigger"
        }, 
        {
            "location": "/module-manager/#locatorregistrationlistener", 
            "text": "If a module class implements  Zend\\ModuleManager\\Feature\\LocatorRegisteredInterface ,\nthis listener will inject the module class instance into the  ServiceManager \nusing the module class name as the service name. This allows you to later\nretrieve the module class from the  ServiceManager .", 
            "title": "LocatorRegistrationListener"
        }, 
        {
            "location": "/module-manager/#moduleresolverlistener", 
            "text": "This is the default module resolver. It attaches to the  loadModule.resolve \nevent and returns an instance of  {moduleName}\\Module .", 
            "title": "ModuleResolverListener"
        }, 
        {
            "location": "/module-manager/#onbootstraplistener", 
            "text": "If a module class implements Zend\\ModuleManager\\Feature\\BootstrapListenerInterface , or defines an onBootstrap()  method, this listener will register the  onBootstrap()  method\nwith the  Zend\\Mvc\\Application   bootstrap  event. This method will then be\ntriggered during the  bootstrap  event (and passed an  MvcEvent  instance).  Like the  InitTrigger , the  onBootstrap()  method is called for  every \nmodule implementing this feature, on  every  page request, and should  only \nbe used for performing  lightweight  tasks such as registering event\nlisteners.", 
            "title": "OnBootstrapListener"
        }, 
        {
            "location": "/module-manager/#servicelistener", 
            "text": "If a module class implements  Zend\\ModuleManager\\Feature\\ServiceProviderInterface ,\nor defines an  getServiceConfig()  method, this listener will call that method\nand aggregate the return values for use in configuring the  ServiceManager .  The  getServiceConfig()  method may return either an array of configuration\ncompatible with  Zend\\ServiceManager\\Config , an instance of that class, or the\nstring name of a class that extends it. Values are merged and aggregated on\ncompletion, and then merged with any configuration from the  ConfigListener \nfalling under the  service_manager  key. For more information, see the ServiceManager  documentation.  Unlike the other listeners, this listener is not managed by the  DefaultListenerAggregate ;\ninstead, it is created and instantiated within the Zend\\Mvc\\Service\\ModuleManagerFactory , where it is injected with the current ServiceManager  instance before being registered with the  ModuleManager \nevents.  Additionally, this listener manages a variety of plugin managers, including view helpers , controllers , and controller plugins . In each case,\nyou may either specify configuration to define plugins, or provide configuration via a  Module \nclass. Configuration follows the same format as for the  ServiceManager . The following table\noutlines the plugin managers that may be configured this way (including the  ServiceManager ), the\nconfiguration key to use, the  ModuleManager  feature interface to optionally implement (all\ninterfaces specified live in the  Zend\\ModuleManager\\Feature  namespace) , and the module method to\noptionally define to provide configuration.     Plugin Manager  Config Key  Interface  Module Method      Zend\\Mvc\\Controller\\ControllerManager  controllers  ControllerProviderInterface  getControllerConfig    Zend\\Mvc\\Controller\\PluginManager  controller_plugins  ControllerPluginProviderInterface  getControllerPluginConfig    Zend\\Filter\\FilterPluginManager  filters  FilterProviderInterface  getFilterConfig    Zend\\Form\\FormElementManager  form_elements  FormElementProviderInterface  getFormElementConfig    Zend\\Stdlib\\Hydrator\\HydratorPluginManager  hydrators  HydratorProviderInterface  getHydratorConfig    Zend\\InputFilter\\InputFilterPluginManager  input_filters  InputFilterProviderInterface  getInputFilterConfig    Zend\\Mvc\\Router\\RoutePluginManager  route_manager  RouteProviderInterface  getRouteConfig    Zend\\Serializer\\AdapterPluginManager  serializers  SerializerProviderInterface  getSerializerConfig    Zend\\ServiceManager\\ServiceManager  service_manager  ServiceProviderInterface  getServiceConfig    Zend\\Validator\\ValidatorPluginManager  validators  ValidatorProviderInterface  getValidatorConfig    Zend\\View\\HelperPluginManager  view_helpers  ViewHelperProviderInterface  getViewHelperConfig    Zend\\Log\\ProcessorPluginManager  log_processors  LogProcessorProviderInterface  getLogProcessorConfig    Zend\\Log\\WriterPluginManager  log_writers  LogWriterProviderInterface  getLogWriterConfig     Configuration follows the examples in the ServiceManager configuration section .\nAs a brief recap, the following configuration keys and values are allowed:     Config Key  Allowed values      services  service name/instance pairs (these should likely be defined only in  Module  classes    invokables  service name/class name pairs of classes that may be invoked without constructor arguments (deprecated with zend-servicemanager v3; use the  InvokableFactory  instead)    factories  service names pointing to factories. Factories may be any PHP callable, or a string class name of a class implementing  Zend\\ServiceManager\\FactoryInterface , or of a class implementing the  __invoke  method (if a callable is used, it should be defined only in  Module  classes)    abstract_factories  array of either concrete instances of  Zend\\ServiceManager\\AbstractFactoryInterface , or string class names of classes implementing that interface (if an instance is used, it should be defined only in  Module  classes)    initializers  array of PHP callables or string class names of classes implementing  Zend\\ServiceManager\\InitializerInterface  (if a callable is used, it should be defined only in  Module  classes)     When working with plugin managers, you will be passed the plugin manager instance to factories,\nabstract factories, and initializers. If you need access to the application services, you can use\nthe  getServiceLocator()  method, as in the following example:  public function getViewHelperConfig()\n{\n    return ['factories' =  [\n        'foo' =  function ($helpers) {\n            $container   = $helpers- getServiceLocator();\n            $someService = $container- get('SomeService');\n            $helper      = new Helper\\Foo($someService);\n\n            return $helper;\n        },\n    ]];\n}  This is a powerful technique, as it allows your various plugins to remain\nagnostic with regards to where and how dependencies are injected, and thus\nallows you to use Inversion of Control principals even with plugins.", 
            "title": "ServiceListener"
        }, 
        {
            "location": "/module-manager/#factories-with-zend-servicemanager-v3", 
            "text": "Starting in the v3 releases of zend-servicemanager, factories invoked by\nplugin managers now receive the  parent  container, and not the plugin manager\nitself. You can write your factories under v2, and prepare them for v3, by\ntesting the incoming argument to see if it is a plugin manager:  use Zend\\SserviceManager\\AbstractPluginManager;\n\nfunction ($container) {\n    $container = $container instanceof AbstractPluginManager\n        ? $container- getServiceLocator()\n        : $container;\n\n    // create instance with dependencies pulled from app container...\n}", 
            "title": "Factories with zend-servicemanager v3"
        }, 
        {
            "location": "/module-class/", 
            "text": "The Module Class\n\n\nBy default, the module system expects each module name to be capable of\nresolving to an object instance. The default module resolver,\n\nZend\\ModuleManager\\Listener\\ModuleResolverListener\n, instantiates an instance\nof \n{moduleName}\\Module\n for each enabled module.\n\n\nA Minimal Module\n\n\nAs an example, provided the module name \"MyModule\",\n\nZend\\ModuleManager\\Listener\\ModuleResolverListener\n will expect the class\n\nMyModule\\Module\n to be available. It relies on a registered autoloader\n(typically \nZend\\Loader\\ModuleAutoloader\n) to find and include the\n\nMyModule\\Module\n class if it isn't already available.\n\n\nThe directory structure of a module named \"MyModule\" might start out looking\nsomething like this:\n\n\nMyModule/\n    Module.php\n\n\n\nWithin \nModule.php\n, you define your \nMyModule\\Module\n class:\n\n\nnamespace MyModule;\n\nclass Module\n{\n}\n\n\n\nThough it will not serve any purpose at this point, this \"MyModule\" module now\nhas everything required to be considered a valid module and to be loaded by the\nmodule system!\n\n\nThis \nModule\n class serves as the single entry point for \nModuleManager\n\nlisteners to interact with a module. From within this class, modules can\noverride or provide additional application configuration, perform initialization\ntasks such as registering autoloader(s), services and event listeners, declaring\ndependencies, and much more.\n\n\nA Typical Module Class\n\n\nThe following example shows a more typical usage of the \nModule\n class:\n\n\nnamespace MyModule;\n\nclass Module\n{\n    public function getAutoloaderConfig()\n    {\n        return [\n            'Zend\\Loader\\ClassMapAutoloader' =\n [\n                __DIR__ . '/autoload_classmap.php',\n            ],\n            'Zend\\Loader\\StandardAutoloader' =\n [\n                'namespaces' =\n [\n                    __NAMESPACE__ =\n __DIR__ . '/src/' . __NAMESPACE__,\n                ],\n            ],\n        ];\n    }\n\n    public function getConfig()\n    {\n        return include __DIR__ . '/config/module.config.php';\n    }\n}\n\n\n\nFor a list of the provided module manager listeners and the interfaces and methods that \nModule\n\nclasses may implement in order to interact with the module manager and application, see the\n\nmodule manager listeners\n and the\n\nmodule mananger events\n documentation.\n\n\nThe loadModules.post Event\n\n\nIt is not safe for a module to assume that any other modules have already been\nloaded at the time \ninit()\n method is called. If your module needs to perform\nany actions after all other modules have been loaded, use the module manager's\n\nloadModules.post\n.\n\n\n\n\nEvent information\n\n\nFor more information on methods like \ninit()\n and \ngetConfig()\n, refer to the\n\nmodule manager listeners documentation\n.\n\n\n\n\nSample Usage of \"loadModules.post\" Event\n\n\nuse Zend\\EventManager\\EventInterface as Event;\nuse Zend\\ModuleManager\\ModuleManager;\n\nclass Module\n{\n    public function init(ModuleManager $moduleManager)\n    {\n        // Remember to keep the init() method as lightweight as possible\n        $events = $moduleManager-\ngetEventManager();\n        $events-\nattach('loadModules.post', [$this, 'modulesLoaded']);\n    }\n\n    public function modulesLoaded(Event $e)\n    {\n        // This method is called once all modules are loaded.\n        $moduleManager = $e-\ngetTarget();\n        $loadedModules = $moduleManager-\ngetLoadedModules();\n\n        // To get the configuration from another module named 'FooModule'\n        $config = $moduleManager-\ngetModule('FooModule')-\ngetConfig();\n    }\n}\n\n\n\n\n\nUse init() sparingly\n\n\nThe \ninit()\n method is called for \nevery\n module implementing this feature,\non \nevery\n page request, and should \nonly\n be used for performing\n\nlightweight\n tasks such as registering event listeners.\n\n\n\n\nThe MVC \"bootstrap\" Event\n\n\nIf you are writing an MVC-oriented module, you may need access to additional\nparts of the application in your \nModule\n class such as the instance of\n\nZend\\Mvc\\Application\n or its registered \nServiceManager\n instance. For this,\nyou may utilize the MVC \nbootstrap\n event. The bootstrap event is triggered\nafter the \nloadModule.post\n event, once \n$application-\nbootstrap()\n is called.\n\n\nSample Usage of the MVC \"bootstrap\" Event\n\n\nuse Zend\\EventManager\\EventInterface as Event;\n\nclass Module\n{\n    public function onBootstrap(Event $e)\n    {\n        // This method is called once the MVC bootstrapping is complete\n        $application = $e-\ngetApplication();\n        $services    = $application-\ngetServiceManager();\n    }\n}\n\n\n\n\n\nUse onBootstrap() sparingly\n\n\nThe \nonBootstrap()\n method is called for \nevery\n module implementing this\nfeature, on \nevery\n page request, and should \nonly\n be used for performing\n\nlightweight\n tasks such as registering event listeners.", 
            "title": "The Module Class"
        }, 
        {
            "location": "/module-class/#the-module-class", 
            "text": "By default, the module system expects each module name to be capable of\nresolving to an object instance. The default module resolver, Zend\\ModuleManager\\Listener\\ModuleResolverListener , instantiates an instance\nof  {moduleName}\\Module  for each enabled module.", 
            "title": "The Module Class"
        }, 
        {
            "location": "/module-class/#a-minimal-module", 
            "text": "As an example, provided the module name \"MyModule\", Zend\\ModuleManager\\Listener\\ModuleResolverListener  will expect the class MyModule\\Module  to be available. It relies on a registered autoloader\n(typically  Zend\\Loader\\ModuleAutoloader ) to find and include the MyModule\\Module  class if it isn't already available.  The directory structure of a module named \"MyModule\" might start out looking\nsomething like this:  MyModule/\n    Module.php  Within  Module.php , you define your  MyModule\\Module  class:  namespace MyModule;\n\nclass Module\n{\n}  Though it will not serve any purpose at this point, this \"MyModule\" module now\nhas everything required to be considered a valid module and to be loaded by the\nmodule system!  This  Module  class serves as the single entry point for  ModuleManager \nlisteners to interact with a module. From within this class, modules can\noverride or provide additional application configuration, perform initialization\ntasks such as registering autoloader(s), services and event listeners, declaring\ndependencies, and much more.", 
            "title": "A Minimal Module"
        }, 
        {
            "location": "/module-class/#a-typical-module-class", 
            "text": "The following example shows a more typical usage of the  Module  class:  namespace MyModule;\n\nclass Module\n{\n    public function getAutoloaderConfig()\n    {\n        return [\n            'Zend\\Loader\\ClassMapAutoloader' =  [\n                __DIR__ . '/autoload_classmap.php',\n            ],\n            'Zend\\Loader\\StandardAutoloader' =  [\n                'namespaces' =  [\n                    __NAMESPACE__ =  __DIR__ . '/src/' . __NAMESPACE__,\n                ],\n            ],\n        ];\n    }\n\n    public function getConfig()\n    {\n        return include __DIR__ . '/config/module.config.php';\n    }\n}  For a list of the provided module manager listeners and the interfaces and methods that  Module \nclasses may implement in order to interact with the module manager and application, see the module manager listeners  and the module mananger events  documentation.", 
            "title": "A Typical Module Class"
        }, 
        {
            "location": "/module-class/#the-loadmodulespost-event", 
            "text": "It is not safe for a module to assume that any other modules have already been\nloaded at the time  init()  method is called. If your module needs to perform\nany actions after all other modules have been loaded, use the module manager's loadModules.post .", 
            "title": "The loadModules.post Event"
        }, 
        {
            "location": "/module-class/#event-information", 
            "text": "For more information on methods like  init()  and  getConfig() , refer to the module manager listeners documentation .", 
            "title": "Event information"
        }, 
        {
            "location": "/module-class/#sample-usage-of-loadmodulespost-event", 
            "text": "use Zend\\EventManager\\EventInterface as Event;\nuse Zend\\ModuleManager\\ModuleManager;\n\nclass Module\n{\n    public function init(ModuleManager $moduleManager)\n    {\n        // Remember to keep the init() method as lightweight as possible\n        $events = $moduleManager- getEventManager();\n        $events- attach('loadModules.post', [$this, 'modulesLoaded']);\n    }\n\n    public function modulesLoaded(Event $e)\n    {\n        // This method is called once all modules are loaded.\n        $moduleManager = $e- getTarget();\n        $loadedModules = $moduleManager- getLoadedModules();\n\n        // To get the configuration from another module named 'FooModule'\n        $config = $moduleManager- getModule('FooModule')- getConfig();\n    }\n}", 
            "title": "Sample Usage of \"loadModules.post\" Event"
        }, 
        {
            "location": "/module-class/#use-init-sparingly", 
            "text": "The  init()  method is called for  every  module implementing this feature,\non  every  page request, and should  only  be used for performing lightweight  tasks such as registering event listeners.", 
            "title": "Use init() sparingly"
        }, 
        {
            "location": "/module-class/#the-mvc-bootstrap-event", 
            "text": "If you are writing an MVC-oriented module, you may need access to additional\nparts of the application in your  Module  class such as the instance of Zend\\Mvc\\Application  or its registered  ServiceManager  instance. For this,\nyou may utilize the MVC  bootstrap  event. The bootstrap event is triggered\nafter the  loadModule.post  event, once  $application- bootstrap()  is called.", 
            "title": "The MVC \"bootstrap\" Event"
        }, 
        {
            "location": "/module-class/#sample-usage-of-the-mvc-bootstrap-event", 
            "text": "use Zend\\EventManager\\EventInterface as Event;\n\nclass Module\n{\n    public function onBootstrap(Event $e)\n    {\n        // This method is called once the MVC bootstrapping is complete\n        $application = $e- getApplication();\n        $services    = $application- getServiceManager();\n    }\n}", 
            "title": "Sample Usage of the MVC \"bootstrap\" Event"
        }, 
        {
            "location": "/module-class/#use-onbootstrap-sparingly", 
            "text": "The  onBootstrap()  method is called for  every  module implementing this\nfeature, on  every  page request, and should  only  be used for performing lightweight  tasks such as registering event listeners.", 
            "title": "Use onBootstrap() sparingly"
        }, 
        {
            "location": "/module-autoloader/", 
            "text": "The Module Autoloader\n\n\nzend-modulemanager ships with the default module autoloader\n\nZend\\Loader\\ModuleAutoloader\n. It is a specialized autoloader responsible for\nlocating and on-demand loading of, the \nModule\n classes from a variety of\nsources.\n\n\nModule Autoloader Usage\n\n\nBy default, the provided \nZend\\ModuleManager\\Listener\\DefaultListenerAggregate\n\nsets up the \nModuleAutoloader\n; as a developer, you need only provide an array\nof module paths, either absolute or relative to the application's root, for the\n\nModuleAutoloader\n to check when loading modules. The \nDefaultListenerAggregate\n\nwill take care of instantiating and registering the \nModuleAutoloader\n for you.\n\n\n\n\nMust be in application root\n\n\nIn order for paths relative to your application directory to work, you must\nhave the directive \nchdir(dirname(__DIR__));\n in your \npublic/index.php\n file.\n\n\n\n\nRegistering module paths with the \nDefaultListenerAggregate\n\n\nThe following example will search for modules in three different \nmodule_paths\n.\nTwo are local directories of this application and the third is a system-wide\nshared directory.\n\n\n// public/index.php\nuse Zend\\ModuleManager\\Listener;\nuse Zend\\ModuleManager\\ModuleManager;\n\nchdir(dirname(__DIR__));\n\n// Instantiate and configure the default listener aggregate\n$listenerOptions = new Listener\\ListenerOptions([\n    'module_paths' =\n [\n        './module',\n        './vendor',\n        '/usr/share/zfmodules',\n    ]\n]);\n$defaultListeners = new Listener\\DefaultListenerAggregate($listenerOptions);\n\n// Instantiate the module manager\n$moduleManager = new ModuleManager([\n    'Application',\n    'FooModule',\n    'BarModule',\n]);\n\n// Attach the default listener aggregate and load the modules\n$moduleManager-\ngetEventManager()-\nattachAggregate($defaultListeners);\n$moduleManager-\nloadModules();\n\n\n\n\n\nModule paths are FIFO\n\n\nModule paths behave very similar to PHP's \ninclude_path\n and are searched in\nthe order they are defined. If you have modules with the same name in more\nthan one registered module path, the module autoloader will return the first\none it finds.\n\n\n\n\nNon-Standard / Explicit Module Paths\n\n\nSometimes you may want to specify exactly where a module is instead of having\n\nZend\\Loader\\ModuleAutoloader\n try to find it in the registered paths.\n\n\nRegistering a Non-Standard / Explicit Module Path\n\n\nIn this example, the autoloader will first check for \nMyModule\\Module\n in\n\n/path/to/mymoduledir-v1.2/Module.php\n. If it's not found, then it will fall\nback to searching any other registered module paths.\n\n\n// ./public/index.php\nuse Zend\\Loader\\ModuleAutoloader;\nuse Zend\\ModuleManager\\Listener;\nuse Zend\\ModuleManager\\ModuleManager;\n\nchdir(dirname(__DIR__));\n\n// Instantiate and configure the default listener aggregate\n$listenerOptions = new Listener\\ListenerOptions([\n    'module_paths' =\n [\n        './module',\n        './vendor',\n        '/usr/share/zfmodules',\n        'MyModule' =\n '/path/to/mymoduledir-v1.2',\n    ]\n]);\n$defaultListeners = new Listener\\DefaultListenerAggregate($listenerOptions);\n\n/**\n * Without DefaultListenerAggregate:\n *\n * $moduleAutoloader = new ModuleAutoloader([\n *     './module',\n *     './vendor',\n *     '/usr/share/zfmodules',\n *     'MyModule' =\n '/path/to/mymoduledir-v1.2',\n * ]);\n * $moduleAutoloader-\nregister();\n *\n */\n\n// Instantiate the module manager\n$moduleManager = new ModuleManager([\n    'MyModule',\n    'FooModule',\n    'BarModule',\n]);\n\n// Attach the default listener aggregate and load the modules\n$moduleManager-\ngetEventManager()-\nattachAggregate($defaultListeners);\n$moduleManager-\nloadModules();\n\n\n\nThis same method works if you provide the path to a phar archive.\n\n\nPackaging Modules with Phar\n\n\nIf you prefer, you may easily package your module as a\n\nphar archive\n. The module autoloader is able to autoload\nmodules in the following archive formats: .phar, .phar.gz, .phar.bz2, .phar.tar,\n.phar.tar.gz, .phar.tar.bz2, .phar.zip, .tar, .tar.gz, .tar.bz2, and .zip.\n\n\nPackage your module by performing a tar the module directory. You can then\nreplace the \nMyModule/\n directory with \nMyModule.tar\n, and it should still be\nautoloaded without any additional changes!\n\n\n\n\nAvoid compression\n\n\nIf possible, avoid using any type of compression (bz2, gz, zip) on your phar\narchives, as it introduces unnecessary CPU overhead to each request.", 
            "title": "The Module Autoloader"
        }, 
        {
            "location": "/module-autoloader/#the-module-autoloader", 
            "text": "zend-modulemanager ships with the default module autoloader Zend\\Loader\\ModuleAutoloader . It is a specialized autoloader responsible for\nlocating and on-demand loading of, the  Module  classes from a variety of\nsources.", 
            "title": "The Module Autoloader"
        }, 
        {
            "location": "/module-autoloader/#module-autoloader-usage", 
            "text": "By default, the provided  Zend\\ModuleManager\\Listener\\DefaultListenerAggregate \nsets up the  ModuleAutoloader ; as a developer, you need only provide an array\nof module paths, either absolute or relative to the application's root, for the ModuleAutoloader  to check when loading modules. The  DefaultListenerAggregate \nwill take care of instantiating and registering the  ModuleAutoloader  for you.", 
            "title": "Module Autoloader Usage"
        }, 
        {
            "location": "/module-autoloader/#must-be-in-application-root", 
            "text": "In order for paths relative to your application directory to work, you must\nhave the directive  chdir(dirname(__DIR__));  in your  public/index.php  file.", 
            "title": "Must be in application root"
        }, 
        {
            "location": "/module-autoloader/#registering-module-paths-with-the-defaultlisteneraggregate", 
            "text": "The following example will search for modules in three different  module_paths .\nTwo are local directories of this application and the third is a system-wide\nshared directory.  // public/index.php\nuse Zend\\ModuleManager\\Listener;\nuse Zend\\ModuleManager\\ModuleManager;\n\nchdir(dirname(__DIR__));\n\n// Instantiate and configure the default listener aggregate\n$listenerOptions = new Listener\\ListenerOptions([\n    'module_paths' =  [\n        './module',\n        './vendor',\n        '/usr/share/zfmodules',\n    ]\n]);\n$defaultListeners = new Listener\\DefaultListenerAggregate($listenerOptions);\n\n// Instantiate the module manager\n$moduleManager = new ModuleManager([\n    'Application',\n    'FooModule',\n    'BarModule',\n]);\n\n// Attach the default listener aggregate and load the modules\n$moduleManager- getEventManager()- attachAggregate($defaultListeners);\n$moduleManager- loadModules();", 
            "title": "Registering module paths with the DefaultListenerAggregate"
        }, 
        {
            "location": "/module-autoloader/#module-paths-are-fifo", 
            "text": "Module paths behave very similar to PHP's  include_path  and are searched in\nthe order they are defined. If you have modules with the same name in more\nthan one registered module path, the module autoloader will return the first\none it finds.", 
            "title": "Module paths are FIFO"
        }, 
        {
            "location": "/module-autoloader/#non-standard-explicit-module-paths", 
            "text": "Sometimes you may want to specify exactly where a module is instead of having Zend\\Loader\\ModuleAutoloader  try to find it in the registered paths.", 
            "title": "Non-Standard / Explicit Module Paths"
        }, 
        {
            "location": "/module-autoloader/#registering-a-non-standard-explicit-module-path", 
            "text": "In this example, the autoloader will first check for  MyModule\\Module  in /path/to/mymoduledir-v1.2/Module.php . If it's not found, then it will fall\nback to searching any other registered module paths.  // ./public/index.php\nuse Zend\\Loader\\ModuleAutoloader;\nuse Zend\\ModuleManager\\Listener;\nuse Zend\\ModuleManager\\ModuleManager;\n\nchdir(dirname(__DIR__));\n\n// Instantiate and configure the default listener aggregate\n$listenerOptions = new Listener\\ListenerOptions([\n    'module_paths' =  [\n        './module',\n        './vendor',\n        '/usr/share/zfmodules',\n        'MyModule' =  '/path/to/mymoduledir-v1.2',\n    ]\n]);\n$defaultListeners = new Listener\\DefaultListenerAggregate($listenerOptions);\n\n/**\n * Without DefaultListenerAggregate:\n *\n * $moduleAutoloader = new ModuleAutoloader([\n *     './module',\n *     './vendor',\n *     '/usr/share/zfmodules',\n *     'MyModule' =  '/path/to/mymoduledir-v1.2',\n * ]);\n * $moduleAutoloader- register();\n *\n */\n\n// Instantiate the module manager\n$moduleManager = new ModuleManager([\n    'MyModule',\n    'FooModule',\n    'BarModule',\n]);\n\n// Attach the default listener aggregate and load the modules\n$moduleManager- getEventManager()- attachAggregate($defaultListeners);\n$moduleManager- loadModules();  This same method works if you provide the path to a phar archive.", 
            "title": "Registering a Non-Standard / Explicit Module Path"
        }, 
        {
            "location": "/module-autoloader/#packaging-modules-with-phar", 
            "text": "If you prefer, you may easily package your module as a phar archive . The module autoloader is able to autoload\nmodules in the following archive formats: .phar, .phar.gz, .phar.bz2, .phar.tar,\n.phar.tar.gz, .phar.tar.bz2, .phar.zip, .tar, .tar.gz, .tar.bz2, and .zip.  Package your module by performing a tar the module directory. You can then\nreplace the  MyModule/  directory with  MyModule.tar , and it should still be\nautoloaded without any additional changes!", 
            "title": "Packaging Modules with Phar"
        }, 
        {
            "location": "/module-autoloader/#avoid-compression", 
            "text": "If possible, avoid using any type of compression (bz2, gz, zip) on your phar\narchives, as it introduces unnecessary CPU overhead to each request.", 
            "title": "Avoid compression"
        }, 
        {
            "location": "/best-practices/", 
            "text": "Best Practices when Creating Modules\n\n\nWhen creating a ZF2 module, there are some best practices you should keep in mind.\n\n\nKeep the \ninit()\n and \nonBootstrap()\n methods lightweight\n\n\nBe conservative with the actions you perform in the \ninit()\n and \nonBootstrap()\n\nmethods of your \nModule\n class. These methods are run for \nevery\n page\nrequest, and should not perform anything heavy. As a rule of thumb, registering\nevent listeners is an appropriate task to perform in these methods. Such\nlightweight tasks will generally not have a measurable impact on the performance\nof your application, even with many modules enabled. It is considered bad\npractice to utilize these methods for setting up or configuring instances of\napplication resources such as a database connection, application logger, or\nmailer. Tasks such as these are better served through the \nServiceManager\n\ncapabilities.\n\n\nDo not perform writes within a module\n\n\nYou should \nnever\n code your module to perform or expect any writes within the\nmodule's directory.  Once installed, the files within a module's directory\nshould always match the distribution verbatim.  Any user-provided configuration\nshould be performed via overrides in the \nApplication\n module or via\napplication-level configuration files. Any other required filesystem writes\nshould be performed in some writeable path that is outside of the module's\ndirectory.\n\n\nThere are two primary advantages to following this rule. First, any modules\nwhich attempt to write within themselves will not be compatible with phar\npackaging. Second, by keeping the module in sync with the upstream distribution,\nupdates via mechanisms such as git will be simple and trouble-free.  Of course,\nthe \nApplication\n module is a special exception to this rule, as there is\ntypically no upstream distribution for this module, and it's unlikely you would\nwant to run this package from within a phar archive.\n\n\nUtilize a vendor prefix for module names\n\n\nTo avoid module naming conflicts, you are encouraged to prefix your module\nnamespace with a vendor prefix. As an example, the developer tools module\ndistributed by Zend is named \"ZendDeveloperTools\" instead of simply\n\"DeveloperTools\".\n\n\nUtilize a module prefix for service names\n\n\nIf you define services in the top-level service manager, you are encouraged to\nprefix these services with the name of your module to avoid conflicts with other\nmodules' services. For example, the database adapter used by MyModule should be\ncalled \"MyModuleDbAdapter\" rather than simply \"DbAdapter.\" If you need to share\na service with other modules, remember that the Service Manager \"alias\" feature\ncan be used in a merged configuration to override factories defined by\nindividual modules. Ideally, modules should define their own service\ndependencies, but aliases can be configured at the application level to ensure\nthat common services in individual modules all refer to the same instance.", 
            "title": "Best Practices when Creating Modules"
        }, 
        {
            "location": "/best-practices/#best-practices-when-creating-modules", 
            "text": "When creating a ZF2 module, there are some best practices you should keep in mind.", 
            "title": "Best Practices when Creating Modules"
        }, 
        {
            "location": "/best-practices/#keep-the-init-and-onbootstrap-methods-lightweight", 
            "text": "Be conservative with the actions you perform in the  init()  and  onBootstrap() \nmethods of your  Module  class. These methods are run for  every  page\nrequest, and should not perform anything heavy. As a rule of thumb, registering\nevent listeners is an appropriate task to perform in these methods. Such\nlightweight tasks will generally not have a measurable impact on the performance\nof your application, even with many modules enabled. It is considered bad\npractice to utilize these methods for setting up or configuring instances of\napplication resources such as a database connection, application logger, or\nmailer. Tasks such as these are better served through the  ServiceManager \ncapabilities.", 
            "title": "Keep the init() and onBootstrap() methods lightweight"
        }, 
        {
            "location": "/best-practices/#do-not-perform-writes-within-a-module", 
            "text": "You should  never  code your module to perform or expect any writes within the\nmodule's directory.  Once installed, the files within a module's directory\nshould always match the distribution verbatim.  Any user-provided configuration\nshould be performed via overrides in the  Application  module or via\napplication-level configuration files. Any other required filesystem writes\nshould be performed in some writeable path that is outside of the module's\ndirectory.  There are two primary advantages to following this rule. First, any modules\nwhich attempt to write within themselves will not be compatible with phar\npackaging. Second, by keeping the module in sync with the upstream distribution,\nupdates via mechanisms such as git will be simple and trouble-free.  Of course,\nthe  Application  module is a special exception to this rule, as there is\ntypically no upstream distribution for this module, and it's unlikely you would\nwant to run this package from within a phar archive.", 
            "title": "Do not perform writes within a module"
        }, 
        {
            "location": "/best-practices/#utilize-a-vendor-prefix-for-module-names", 
            "text": "To avoid module naming conflicts, you are encouraged to prefix your module\nnamespace with a vendor prefix. As an example, the developer tools module\ndistributed by Zend is named \"ZendDeveloperTools\" instead of simply\n\"DeveloperTools\".", 
            "title": "Utilize a vendor prefix for module names"
        }, 
        {
            "location": "/best-practices/#utilize-a-module-prefix-for-service-names", 
            "text": "If you define services in the top-level service manager, you are encouraged to\nprefix these services with the name of your module to avoid conflicts with other\nmodules' services. For example, the database adapter used by MyModule should be\ncalled \"MyModuleDbAdapter\" rather than simply \"DbAdapter.\" If you need to share\na service with other modules, remember that the Service Manager \"alias\" feature\ncan be used in a merged configuration to override factories defined by\nindividual modules. Ideally, modules should define their own service\ndependencies, but aliases can be configured at the application level to ensure\nthat common services in individual modules all refer to the same instance.", 
            "title": "Utilize a module prefix for service names"
        }
    ]
}